\section{Тест производительности}
Сравним полученный алгоритм с наивным алгоритмом. Наивный алгоритм просто
перебирает все возможные варианты разрезов и ищет среди них лексикографически
наименьший.\newline

\begin{alltt}
den@vbox:~/Документы/DA/lab5$ ./a.out <test500
Time: 0.001716 ms
den@vbox:~/Документы/DA/lab5$ ./naive <test500
Time: 0.00017 ms
den@vbox:~/Документы/DA/lab5$ ./a.out <test1e4
Time: 0.0329882 ms
den@vbox:~/Документы/DA/lab5$ ./naive <test1e4
Time: 0.0042473 ms
den@vbox:~/Документы/DA/lab5$ ./a.out <test1e6
Time: 4.08355 ms
den@vbox:~/Документы/DA/lab5$ ./naive <test1e6
Time: 73.1969 ms
\end{alltt}

Видим, что на маленьких строках суффиксное дерево немного уступает наивному
алгоритму. Это связано с тем, что построение дерева тоже требует времени. Однако на большой строке видно все преимущество суффиксных деревьев - выигрыш
примерно в 18 раз. Это связано с тем, что наивный алгоритм работает за $O(n^2)$ -
мы проверям $n$ разрезов, каждый из которых сравниваем с текущим минимальным, сравнение строк происходит за $O(n)$.\newline

\pagebreak